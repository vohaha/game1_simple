Domain Architecture Overview for Game1

1. Purpose

This document provides a strategic overview of the domain architecture for Game1, grounded in the principles of Domain-Driven Design (DDD). It defines the core domain, outlines bounded contexts, maps their relationships, and clarifies the strategic roles of each context. The goal is to improve shared understanding across development, design, and strategic planning.

‚∏ª

2. Core Domain

üéØ Definition

Game1‚Äôs Core Domain is the simulation of human-like decision-making and social-economic interaction via:
	‚Ä¢	Energy-as-Action System
	‚Ä¢	Deal System
	‚Ä¢	Individual Identity Mechanics
	‚Ä¢	Production and Value Creation

These domains abstract real-world constraints such as cognitive limits, energy depletion, time preferences, and social cooperation mechanisms.

üî• Why It Matters

These systems define:
	‚Ä¢	What players can do
	‚Ä¢	How they exchange value
	‚Ä¢	How effort is limited and allocated
	‚Ä¢	How social trust and productivity emerge

‚∏ª

3. Bounded Contexts

Below are the key bounded contexts in Game1:

Context	Responsibility
Energy System	Manages action capacity, sleep, tokenization, and regeneration
Individual	Models player character, identity spectrum, skills, and psychological traits
Production	Governs product and service creation, pausing, efficiency, complexity
Group	Represents collective effort, roles, specialization, internal dynamics
Deal System	Handles formal agreements between entities, term enforcement, reputation
Network	Manages connections, reputation, social capital, economic signals
Time System	Tracks real-time, circadian preferences, debuffs, and scheduling
Progression	Tracks skill evolution, diminishing returns, identity shifts
Balance	Observes the ecosystem and applies balancing actions


‚∏ª

4. Context Map

‚ö° Interaction Types
	‚Ä¢	Energy ‚Üê Individual ‚Äî Core usage of action capacity (Customer/Supplier)
	‚Ä¢	Production ‚Üê Energy & Individual ‚Äî Depends on their state to perform tasks (Customer/Supplier)
	‚Ä¢	Group ‚Üê Individual ‚Äî Groups aggregate individuals (Composite)
	‚Ä¢	Deal ‚Üî Group & Individual ‚Äî Mediates interactions (Mediator Pattern)
	‚Ä¢	Progression ‚Üí Individual & Production ‚Äî Learns from their activity (Observer)
	‚Ä¢	Network ‚Üî Individual/Group ‚Äî Broadcasts and filters interactions (Mediator)

üó∫ Diagram Key

[Individual] ‚Üêuses‚Äî [Energy System]
     ‚Üì                       ‚Üì
[Progression]      ‚Üêobserves‚Äî
     ‚Üì
[Production] ‚Üêuses‚Äî [Time System]
     ‚Üì
[Group] ‚Üêcomposes‚Äî [Individual]
     ‚Üì                   ‚Üì
[Deal System] ‚Üî mediates ‚Üî [Network]
     ‚Üì
[Balance] ‚Üêobserves all ‚Üí adjusts


‚∏ª

5. Strategic Roles

Context	Role	Notes
Energy System	Core	Everything depends on energy capacity and regeneration
Individual	Core	Represents the atomic decision-maker and capability holder
Production System	Core	Primary means of expressing effort into value
Group	Supporting	Aggregates individuals, increases complexity potential
Deal System	Supporting	Orchestrates formal cooperation
Network	Generic	Supports communication, reputation, and value propagation
Time System	Generic	Provides shared rhythm, buffs/debuffs, scheduling
Progression	Supporting	Emergent identity and capability evolution
Balance	Generic	Regulates feedback but not part of core gameplay decisions


‚∏ª

6. Capability Map

Capability	Implemented In
Manage personal energy	Energy, Individual
Create products/services	Production, Individual
Form and operate groups	Group, Deal
Make and enforce agreements	Deal System, Network
Trade and transmit value	Energy (tokens), Network
Build identity and reputation	Individual, Network
Learn and specialize	Progression, Production
Observe and adapt systems	Balance, Deal, Production


‚∏ª

7. Integration Guidelines
	‚Ä¢	Use published interfaces between contexts (defined via interfaces in /docs/interfaces.md)
	‚Ä¢	Communicate using event-based messaging (Observer Pattern across modules)
	‚Ä¢	Apply Mediator Pattern for orchestrated systems like Deals & Network
	‚Ä¢	Maintain aggregate roots (e.g., Group, Individual) for consistency boundaries

Example: GameEngine
	‚Ä¢	Central entry point (gameEngine.ts) initializes and wires up all modules
	‚Ä¢	Uses IGameContext to expose eventBus, timeSystem, and module registry
	‚Ä¢	Enables creation of entities via factories (defineIndividual, defineGroup)
	‚Ä¢	Drives time progression, action execution, and persistence

‚∏ª

8. Freedom & Entropy Control via Action System

Problem:

Max freedom for players causes uncontrolled complexity across domains.

Solution: introduce Action Layer:
	‚Ä¢	IAction: unified object describing a player action
	‚Ä¢	ActionEngine: central service to validate (via Policy), execute (via Handler)
	‚Ä¢	IActionPolicy: domain-based rule checker (e.g. ‚ÄúGroup must approve join‚Äù)
	‚Ä¢	IActionHandler: encapsulates execution logic
	‚Ä¢	IAbility: lists available actions for UI/agent (context-aware)

Benefits:
	‚Ä¢	Centralized control over possible and valid actions
	‚Ä¢	Easily testable, switchable, and configurable
	‚Ä¢	Game logic emerges from combinations of small, testable action handlers

‚∏ª

9. Evolution and Governance
	‚Ä¢	Track context ownership ‚Äî each context should have maintainers
	‚Ä¢	Add new contexts via capability discovery (e.g. law, governance, religion?)
	‚Ä¢	Update context map and strategic role assessments quarterly
	‚Ä¢	Use event storming to explore new bounded contexts as features evolve

‚∏ª

10. References
	‚Ä¢	‚ÄúDomain-Driven Architecture Diagrams‚Äù ‚Äî Nick Tune (https://medium.com/nick-tune-tech-strategy-blog/domain-driven-architecture-diagrams-139a75acb578)
	‚Ä¢	Game1 Core Documentation (2025-05)
	‚Ä¢	Eric Evans, ‚ÄúDomain-Driven Design‚Äù
	‚Ä¢	Vaughn Vernon, ‚ÄúImplementing DDD‚Äù
	‚Ä¢	ChatGPT Game1 integration discussions (2025-06)
